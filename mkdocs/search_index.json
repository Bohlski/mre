{
    "docs": [
        {
            "location": "/",
            "text": "MRE\n\n\nUm pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler.\n\n\nInstala\u00e7\u00e3o do MRE\n\n\nInstall the MRE package using pip:\n\n\npip install mre",
            "title": "Home"
        },
        {
            "location": "/#mre",
            "text": "Um pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler.",
            "title": "MRE"
        },
        {
            "location": "/#instalacao-do-mre",
            "text": "Install the MRE package using pip:  pip install mre",
            "title": "Instala\u00e7\u00e3o do MRE"
        },
        {
            "location": "/guia-de-uso/",
            "text": "Classes\n\n\n\n\nRegex\n\n\nQuantifier\n\n\nSet\n\n\nGroup\n\n\nAnchor\n\n\nHelper\n\n\nRange\n\n\n\n\n\n\n\n\nRegex\n\n\nEssa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel \nself.rgx\n. Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos: \nstr\n, \nint\n e a pr\u00f3pria classe \nRegex\n. Para entender melhor:\n\n\n\n\nstr\n: concatena \u00e0 vari\u00e1vel \nself.rgx\n;\n\n\nint\n: realiza \nbackreferences\n;\n\n\nRegex\n: concatena o valor armazenado em \nself.rgx\n do objeto que se recebe na vari\u00e1vel \nself.rgx\n do objeto que est\u00e1 recebendo.\n\n\n\n\nFormas de se declarar um \nRegex\n:\n\n\nfrom mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>\n\n\n\n\nConstantes\n\n\nConstantes presentes na classe \nRegex\n:\n\n\n\n\n\n\n\n\nConstante\n\n\nValor\n\n\n\n\n\n\n\n\n\n\nANY\n\n\n.\n\n\n\n\n\n\nDOT\n\n\n\\\\.\n\n\n\n\n\n\nDIGIT\n\n\n\\\\d\n\n\n\n\n\n\nWHITESPACE\n\n\n\\\\s\n\n\n\n\n\n\nWORD_CHARS\n\n\n\\\\w\n\n\n\n\n\n\nSLASH\n\n\n\\\\/.\n\n\n\n\n\n\nNOT_DIGIT\n\n\n\\\\D\n\n\n\n\n\n\nNOT_WHITESPACE\n\n\n\\\\S\n\n\n\n\n\n\nNOT_WORD_CHARS\n\n\n\\\\W\n\n\n\n\n\n\nZERO_OR_ONE\n\n\n?\n\n\n\n\n\n\nZERO_OR_MULTIPLE\n\n\n*\n\n\n\n\n\n\nONE_OR_MULTIPLE\n\n\n+\n\n\n\n\n\n\nHYPHEN\n\n\n\\\\-\n\n\n\n\n\n\n\n\nM\u00e9todos\n\n\nAl\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas.\n\n\n__str__\n\n\nRetorna o valor salvo em \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"\n\n\n\n\n__eq__\n\n\nA compara\u00e7\u00e3o pode ser entre \nstr\n ou \nRegex\n:\n- \n== str\n: compara \nself.rgx\n ao valor da vari\u00e1vel recebida;\n- \n== Regex\n: compara \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False\n\n\n\n\n__iadd__\n\n\nEspera-se vari\u00e1veis de dois tipos: \nstr\n e \nRegex\n. Para entender melhor:\n\n\n\n\n+= str\n: concatena \nself.rgx\n ao valor da vari\u00e1vel recebida;\n\n\n+= Regex\n: concatena \nself.rgx\n ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\n\n\nEssa sobrecarga altera diretamente a vari\u00e1vel \nself.rgx\n, sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto \nSet\n, ir\u00e1 alterar o valor entre os colchetes.\n\n\nfrom mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"\n\n\n\n\n__add__\n\n\nEspera-se vari\u00e1veis de dois tipos: \nstr\n e \nRegex\n. Diferentemente da sobrecarga \n__iadd__\n, essa sobrecarga retorna um novo objeto \nRegex\n.\n\n\n\n\n+ str\n: concatena \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel recebida;\n\n\n+ Regex\n: concatena \nself.rgx\n (acessado atrav\u00e9s do m\u00e9todo \nget\n) ao valor da vari\u00e1vel \nself.rgx\n do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo \nget\n).\n\n\n\n\nfrom mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"\n\n\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n.\n\n\nfrom mre import Regex\n\nregex = Regex(\"Valor armazenado\")\nprint(regex.get())  # \"Valor armazenado\"\n\n\n\n\nquantifier\n\n\nPossui os seguintes par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nServe para quantificar as vezes que o RegEx deve/pode aparecer (de \nn\n at\u00e9 \nm\n). Retorna um novo objeto \nRegex\n.\n\n\nEm casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o:\n\n\n\n\n\n\n\n\nn\n\n\nm\n\n\nwithout_maximum\n\n\nS\u00edmbolo\n\n\nAcesso\n\n\n\n\n\n\n\n\n\n\n0\n\n\n1\n\n\n-\n\n\n?\n\n\nRegex.ZERO_OR_ONE\n\n\n\n\n\n\n0\n\n\n-\n\n\nTrue\n\n\n*\n\n\nRegex.ZERO_OR_MULTIPLE\n\n\n\n\n\n\n1\n\n\n-\n\n\nTrue\n\n\n+\n\n\nRegex.ONE_OR_MULTIPLE\n\n\n\n\n\n\n\n\nAl\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas:\n- \n{n}\n: deve ocorrer \nn\n vezes;\n- \n{n, m}\n: pode ocorrer de \nn\n at\u00e9 \nm\n vezes.\n\n\nfrom mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"\n\n\n\n\nbackreferences\n\n\nPossui um par\u00e2metro do tipo \nint\n (\ngroup_n\n) que serve para indicar qual grupo se deseja realizar a \nbackreference\n. Retorna um \nRegex\n que realiza \nbackreferences\n ao grupo indicado.\n\n\nUm meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um \nint\n no construtor.\n\n\nfrom mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"\n\n\n\n\nQuantifier\n\n\nEssa classe serve como uma alternativa a chamada do m\u00e9todo \nRegex.quantifier\n. Seu construtor recebe 4 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nn\n\n\nint\n\n\n0\n\n\n\n\n\n\nm\n\n\nint\n\n\n0\n\n\n\n\n\n\nwithout_maximum\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nO primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo \nRegex.quantifier\n.\n\n\nfrom mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"\n\n\n\n\nSet\n\n\nEssa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe \nRegex\n.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre colchetes.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"\n\n\n\n\nquantifier\n\n\nRetorna um novo objeto \nRegex\n com o quantificador referente ao conjunto.\n\n\nfrom mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nGroup\n\n\nEssa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnon_capturing\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSe o argumento referente a \nnon_capturing\n for \nTrue\n, ser\u00e1 adicionado os s\u00edmbolos que indicam que a \nRegEx Engine\n n\u00e3o deve retornar o valor daquele grupo (\n?:\n).\n\n\nfrom mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre par\u00eanteses.\n\n\nfrom mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"\n\n\n\n\nquantifier\n\n\nRetorna um novo objeto \nRegex\n com o quantificador referente ao grupo.\n\n\nfrom mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>\n\n\n\n\nAnchor\n\n\nEssa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nregex\n\n\nstr\n, \nint\n, \nRegex\n\n\n\"\"\n\n\n\n\n\n\nnegate\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nSe o argumento referente a \nnegate\n for \nTrue\n, ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, sobrescrevendo apenas os m\u00e9todos a seguir.\n\n\nget\n\n\nRetorna o valor armazenado em \nself.rgx\n, mas entre par\u00eanteses.\n\n\nfrom mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"\n\n\n\n\nhelper.Range\n\n\nEssa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um \nrange\n. Seu construtor recebe 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nstr\n, \nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nstr\n, \nint\n\n\n\"z\"\n\n\n\n\n\n\n\n\nIdealmente usar essa classe junto a classe \nSet\n, pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir \nrange\n, fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar \n[a-z]\n e n\u00e3o apenas \na-z\n, pois assim voc\u00ea est\u00e1 apenas dizendo que quer \na\n, \n-\n e \nz\n.\n\n\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\ndigits = Range(0, 9)\n# Todas as letras\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"\n\n\n\n\nM\u00e9todos\n\n\nEssa classe herda os m\u00e9todos da classe \nRegex\n, al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos.\n\n\ndigits\n\n\nPossui 2 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nint\n\n\n0\n\n\n\n\n\n\nmaximum\n\n\nint\n\n\n9\n\n\n\n\n\n\n\n\nRetorna um \nrange\n que define os d\u00edgitos entre \nminimum\n e \nmaximum\n.\n\n\nfrom mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"\n\n\n\n\nletters\n\n\nPossui 4 par\u00e2metros:\n\n\n\n\n\n\n\n\nPar\u00e2metro\n\n\nTipo\n\n\nValor padr\u00e3o\n\n\n\n\n\n\n\n\n\n\nminimum\n\n\nchr\n\n\nA\n\n\n\n\n\n\nmaximum\n\n\nchr\n\n\nz\n\n\n\n\n\n\nuppercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\nlowercase\n\n\nbool\n\n\nFalse\n\n\n\n\n\n\n\n\nRetorna um \nrange\n que define as letras entre \nminimum\n e \nmaximum\n.\n\n\nfrom mre.helper import Range\n\n# Todas as letras\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# Todas as letras mai\u00fasculas\nregex_range_five = Range().letters(uppercase=True)\n# Todas as letras min\u00fasculas\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"\n\n\n\n\nExemplos\n\n\n2 formas de fazer o RegEx de \nCEP\n (\n[0-9]{5}-?[0-9]{3}\n)\n\n\nfrom mre import Regex, Set\n\n# Todos os d\u00edgitos\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)\n\n\n\n\nfrom mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos [0-9]\ndigits = Set(Range().digits())\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)\n\n\n\n\nRegEx de \nCPF\n (\n[0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2}\n):\n\n\nfrom mre import Regex, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\nall_digits = Set(Range(0, 9))\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)\n\n\n\n\nRegEx de \nCNPJ\n (\n\\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2}\n):\n\n\nfrom mre import Regex, Quantifier\n\n# Todos os d\u00edgitos\ndigits = Regex(Regex.DIGIT)\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# A barra pode aparecer nenhuma ou uma vez\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Guia de uso"
        },
        {
            "location": "/guia-de-uso/#classes",
            "text": "Regex  Quantifier  Set  Group  Anchor  Helper  Range",
            "title": "Classes"
        },
        {
            "location": "/guia-de-uso/#regex",
            "text": "Essa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel  self.rgx . Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos:  str ,  int  e a pr\u00f3pria classe  Regex . Para entender melhor:   str : concatena \u00e0 vari\u00e1vel  self.rgx ;  int : realiza  backreferences ;  Regex : concatena o valor armazenado em  self.rgx  do objeto que se recebe na vari\u00e1vel  self.rgx  do objeto que est\u00e1 recebendo.   Formas de se declarar um  Regex :  from mre import Regex, Group\n\nrgx_one = Regex(\"Hello world\")  # Hello world\nrgx_two = Regex(\"Hello\", \" world\")  # Hello world\nrgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\")  # Hello world\nrgx_four = Regex('<', Group('h[1-6]'), '>')  # <(h[1-6])>\nrgx_five = Regex('<', Regex.SLASH, 1, '>')  # <\\/\\1>",
            "title": "Regex"
        },
        {
            "location": "/guia-de-uso/#constantes",
            "text": "Constantes presentes na classe  Regex :     Constante  Valor      ANY  .    DOT  \\\\.    DIGIT  \\\\d    WHITESPACE  \\\\s    WORD_CHARS  \\\\w    SLASH  \\\\/.    NOT_DIGIT  \\\\D    NOT_WHITESPACE  \\\\S    NOT_WORD_CHARS  \\\\W    ZERO_OR_ONE  ?    ZERO_OR_MULTIPLE  *    ONE_OR_MULTIPLE  +    HYPHEN  \\\\-",
            "title": "Constantes"
        },
        {
            "location": "/guia-de-uso/#metodos",
            "text": "Al\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/guia-de-uso/#9595str9595",
            "text": "Retorna o valor salvo em  self.rgx .  from mre import Regex\n\nregex = Regex(\"Hello world\")\nprint(regex)  # \"Hello world\"",
            "title": "__str__"
        },
        {
            "location": "/guia-de-uso/#9595eq9595",
            "text": "A compara\u00e7\u00e3o pode ser entre  str  ou  Regex :\n-  == str : compara  self.rgx  ao valor da vari\u00e1vel recebida;\n-  == Regex : compara  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel  self.rgx  do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo  get ).  from mre import Regex\n\nregex_one = Regex(\"Hello world\")\n\nprint(regex_one == \"Hello world\")  # True\nprint(regex_one == \"Hello world!\")  # False\n\nprint(regex_one == Regex(\"Hello world\"))  # True\nprint(regex_one == Regex(\"Hello world!\"))  # False",
            "title": "__eq__"
        },
        {
            "location": "/guia-de-uso/#9595iadd9595",
            "text": "Espera-se vari\u00e1veis de dois tipos:  str  e  Regex . Para entender melhor:   += str : concatena  self.rgx  ao valor da vari\u00e1vel recebida;  += Regex : concatena  self.rgx  ao valor da vari\u00e1vel  self.rgx  do objeto recebido (acessado atrav\u00e9s do m\u00e9todo  get ).   Essa sobrecarga altera diretamente a vari\u00e1vel  self.rgx , sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto  Set , ir\u00e1 alterar o valor entre os colchetes.  from mre import Regex, Set\n\nregex = Regex(\"Hello\")\nregex += \" world\"\nprint(regex)  # \"Hello world\"\n\nregex_set = Set(\"Hello\")  # [Hello]\nregex_set += \" world\"\nprint(regex_set)  # \"[Hello world]\"",
            "title": "__iadd__"
        },
        {
            "location": "/guia-de-uso/#9595add9595",
            "text": "Espera-se vari\u00e1veis de dois tipos:  str  e  Regex . Diferentemente da sobrecarga  __iadd__ , essa sobrecarga retorna um novo objeto  Regex .   + str : concatena  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel recebida;  + Regex : concatena  self.rgx  (acessado atrav\u00e9s do m\u00e9todo  get ) ao valor da vari\u00e1vel  self.rgx  do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo  get ).   from mre import Regex\n\nregex_one = Regex(\"Hello\") + \" \" + Regex(\"world\")\nregex_two = Regex(\"Hello\") + Regex(\" world\")\n\nprint(regex_one)  # \"Hello world\"\nprint(regex_two)  # \"Hello world\"",
            "title": "__add__"
        },
        {
            "location": "/guia-de-uso/#get",
            "text": "Retorna o valor armazenado em  self.rgx .  from mre import Regex\n\nregex = Regex(\"Valor armazenado\")\nprint(regex.get())  # \"Valor armazenado\"",
            "title": "get"
        },
        {
            "location": "/guia-de-uso/#quantifier",
            "text": "Possui os seguintes par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      n  int  0    m  int  0    without_maximum  bool  False     Serve para quantificar as vezes que o RegEx deve/pode aparecer (de  n  at\u00e9  m ). Retorna um novo objeto  Regex .  Em casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o:     n  m  without_maximum  S\u00edmbolo  Acesso      0  1  -  ?  Regex.ZERO_OR_ONE    0  -  True  *  Regex.ZERO_OR_MULTIPLE    1  -  True  +  Regex.ONE_OR_MULTIPLE     Al\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas:\n-  {n} : deve ocorrer  n  vezes;\n-  {n, m} : pode ocorrer de  n  at\u00e9  m  vezes.  from mre import Regex\n\ndigits = Regex(\"[0-9]\")\n\nprint(digits.quantifier(3))  # \"[0-9]{3}\"\nprint(digits.quantifier(3, 5))  # \"[0-9]{3,5}\"\nprint(digits.quantifier(0, 1))  # \"[0-9]?\"\nprint(digits.quantifier(0, without_maximum=True))  # \"[0-9]*\"\nprint(digits.quantifier(1, without_maximum=True))  # \"[0-9]+\"",
            "title": "quantifier"
        },
        {
            "location": "/guia-de-uso/#backreferences",
            "text": "Possui um par\u00e2metro do tipo  int  ( group_n ) que serve para indicar qual grupo se deseja realizar a  backreference . Retorna um  Regex  que realiza  backreferences  ao grupo indicado.  Um meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um  int  no construtor.  from mre import Regex\n\nregex_one = Regex().backreferences(1)\nregex_two = Regex(2)\n\nprint(regex_one)  # \"\\1\"\nprint(regex_two)  # \"\\2\"",
            "title": "backreferences"
        },
        {
            "location": "/guia-de-uso/#quantifier_1",
            "text": "Essa classe serve como uma alternativa a chamada do m\u00e9todo  Regex.quantifier . Seu construtor recebe 4 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    n  int  0    m  int  0    without_maximum  bool  False     O primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo  Regex.quantifier .  from mre import Regex, Quantifier\n\ndigits_one = Regex(\"[0-9]\").quantifier(3, 5)\ndigits_two = Quantifier(\"[0-9]\", 3, 5)\n\nprint(digits_one)  # \"[0-9]{3,5}\"\nprint(digits_two)  # \"[0-9]{3,5}\"",
            "title": "Quantifier"
        },
        {
            "location": "/guia-de-uso/#set",
            "text": "Essa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe  Regex .  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"",
            "title": "Set"
        },
        {
            "location": "/guia-de-uso/#metodos_1",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/guia-de-uso/#get_1",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre colchetes.  from mre import Set\n\nregex_set = Set(\"0-9\")\nprint(regex_set.get())  # \"[0-9]\"",
            "title": "get"
        },
        {
            "location": "/guia-de-uso/#quantifier_2",
            "text": "Retorna um novo objeto  Regex  com o quantificador referente ao conjunto.  from mre import Set\n\nregex_set = Set(\"0-9\")\n\nprint(regex_set)  # \"[0-9]\"\nprint(regex_set.quantifier(3))  # \"[0-9]{3}\"\n\nprint(type(regex_set))  # <class 'mre.Set.Set'>\nprint(type(regex_set.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/guia-de-uso/#group",
            "text": "Essa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    non_capturing  bool  False     Se o argumento referente a  non_capturing  for  True , ser\u00e1 adicionado os s\u00edmbolos que indicam que a  RegEx Engine  n\u00e3o deve retornar o valor daquele grupo ( ?: ).  from mre import Group\n\nregex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>')\nregex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True)\n\nprint(regex_group_one)  # (<h1>)([\\w\\s]+)(</h1>)\nprint(regex_group_two)  # (?:<h1>)([\\w\\s]+)(?:</h1>)",
            "title": "Group"
        },
        {
            "location": "/guia-de-uso/#metodos_2",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/guia-de-uso/#get_2",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre par\u00eanteses.  from mre import Group\n\nregex_group_one = Group(\"<h1>\")\nregex_group_two = Group(\"</h1>\", True)\n\nprint(regex_group_one.get())  # \"(<h1>)\"\nprint(regex_group_two.get())  # \"(?:</h1>)\"",
            "title": "get"
        },
        {
            "location": "/guia-de-uso/#quantifier_3",
            "text": "Retorna um novo objeto  Regex  com o quantificador referente ao grupo.  from mre import Group\n\nregex_group = Group(\"<h1>\")\n\nprint(regex_group)  # \"(<h1>)\"\nprint(regex_group.quantifier(3))  # \"(<h1>){3}\"\n\nprint(type(regex_group))  # <class 'mre.Group.Group'>\nprint(type(regex_group.quantifier(3)))  # <class 'mre.Regex.Regex'>",
            "title": "quantifier"
        },
        {
            "location": "/guia-de-uso/#anchor",
            "text": "Essa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      regex  str ,  int ,  Regex  \"\"    negate  bool  False     Se o argumento referente a  negate  for  True , ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\")\nregex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True)\n\nprint(regex_anchor_one)  # \"^\\d{4}-\\w+.txt$\"\nprint(regex_anchor_two)  # \"\\b\\d{4}-\\w+.txt\\B\"",
            "title": "Anchor"
        },
        {
            "location": "/guia-de-uso/#metodos_3",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , sobrescrevendo apenas os m\u00e9todos a seguir.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/guia-de-uso/#get_3",
            "text": "Retorna o valor armazenado em  self.rgx , mas entre par\u00eanteses.  from mre import Anchor\n\nregex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\")\nregex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True)\n\nprint(regex_anchor_one.get())  # \"^<h1>Hello world</h1>$\"\nprint(regex_anchor_two.get())  # \"\\b<h1>Hello world</h1>\\B\"",
            "title": "get"
        },
        {
            "location": "/guia-de-uso/#helperrange",
            "text": "Essa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um  range . Seu construtor recebe 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  str ,  int  0    maximum  str ,  int  \"z\"     Idealmente usar essa classe junto a classe  Set , pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir  range , fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar  [a-z]  e n\u00e3o apenas  a-z , pois assim voc\u00ea est\u00e1 apenas dizendo que quer  a ,  -  e  z .  from mre.helper import Range\n\n# Todos os d\u00edgitos\ndigits = Range(0, 9)\n# Todas as letras\nletters = Range('A', 'z')\n\nprint(digits)  # \"0-9\"\nprint(letters)  # \"A-z\"",
            "title": "helper.Range"
        },
        {
            "location": "/guia-de-uso/#metodos_4",
            "text": "Essa classe herda os m\u00e9todos da classe  Regex , al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos.",
            "title": "M\u00e9todos"
        },
        {
            "location": "/guia-de-uso/#digits",
            "text": "Possui 2 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  int  0    maximum  int  9     Retorna um  range  que define os d\u00edgitos entre  minimum  e  maximum .  from mre.helper import Range\n\nregex_range_one = Range(0, 9)\nregex_range_two = Range().digits()\nregex_range_three = Range(0, 6)\nregex_range_four = Range().digits(0, 6)\n\nprint(regex_range_one)  # \"0-9\"\nprint(regex_range_two)  # \"0-9\"\nprint(regex_range_three)  # \"0-6\"\nprint(regex_range_four)  # \"0-6\"",
            "title": "digits"
        },
        {
            "location": "/guia-de-uso/#letters",
            "text": "Possui 4 par\u00e2metros:     Par\u00e2metro  Tipo  Valor padr\u00e3o      minimum  chr  A    maximum  chr  z    uppercase  bool  False    lowercase  bool  False     Retorna um  range  que define as letras entre  minimum  e  maximum .  from mre.helper import Range\n\n# Todas as letras\nregex_range_one = Range('A', 'z')\nregex_range_two = Range().letters()\nregex_range_three = Range().letters('A', 'z')\nregex_range_four = Range().letters(uppercase=True, lowercase=True)\n# Todas as letras mai\u00fasculas\nregex_range_five = Range().letters(uppercase=True)\n# Todas as letras min\u00fasculas\nregex_range_six = Range().letters(lowercase=True)\n\nprint(regex_range_one)  # \"A-z\"\nprint(regex_range_two)  # \"A-z\"\nprint(regex_range_three)  # \"A-z\"\nprint(regex_range_four)  # \"A-z\"\nprint(regex_range_five)  # \"A-Z\"\nprint(regex_range_six)  # \"a-z\"",
            "title": "letters"
        },
        {
            "location": "/guia-de-uso/#exemplos",
            "text": "2 formas de fazer o RegEx de  CEP  ( [0-9]{5}-?[0-9]{3} )  from mre import Regex, Set\n\n# Todos os d\u00edgitos\ndigits = Set(Regex(\"0-9\"))\n\nrgx_cep = Regex(\n    digits.quantifier(5),\n    Regex(\"-\").quantifier(0, 1),\n    digits.quantifier(3),\n)  from mre import Regex, Quantifier, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos [0-9]\ndigits = Set(Range().digits())\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cep = Regex(\n    digits.quantifier(5), hyphen,\n    digits.quantifier(3),\n)  RegEx de  CPF  ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ):  from mre import Regex, Set\nfrom mre.helper import Range\n\n# Todos os d\u00edgitos\nall_digits = Set(Range(0, 9))\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Regex('-').quantifier(0, 1)\n\nrgx_cpf = Regex(\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), dot,\n    all_digits.quantifier(3), hyphen,\n    all_digits.quantifier(2),\n)  RegEx de  CNPJ  ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ):  from mre import Regex, Quantifier\n\n# Todos os d\u00edgitos\ndigits = Regex(Regex.DIGIT)\n# O ponto pode aparecer nenhuma ou uma vez\ndot = Regex(Regex.DOT).quantifier(0, 1)\n# A barra pode aparecer nenhuma ou uma vez\nslash = Regex(Regex.SLASH).quantifier(0, 1)\n# O h\u00edfen pode aparecer nenhuma ou uma vez\nhyphen = Quantifier(\"-\", 0, 1)\n\nrgx_cnpj = Regex(\n    digits.quantifier(2), dot,\n    digits.quantifier(3), dot,\n    digits.quantifier(3), slash,\n    digits.quantifier(4), hyphen,\n    digits.quantifier(2),\n)",
            "title": "Exemplos"
        },
        {
            "location": "/idiomas/",
            "text": "Idiomas\n\n\nPortugu\u00eas, Brasil",
            "title": "Idiomas"
        },
        {
            "location": "/idiomas/#idiomas",
            "text": "Portugu\u00eas, Brasil",
            "title": "Idiomas"
        },
        {
            "location": "/licenca/",
            "text": "MIT License\n\n\nCopyright (c) 2018 The Python Packaging Authority\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "Licenca"
        },
        {
            "location": "/licenca/#mit-license",
            "text": "Copyright (c) 2018 The Python Packaging Authority  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
            "title": "MIT License"
        },
        {
            "location": "/sobre/",
            "text": "This a simple package to make regular expression in Python.",
            "title": "Sobre"
        }
    ]
}